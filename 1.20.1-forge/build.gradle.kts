import java.text.SimpleDateFormat
import java.util.Date

plugins {
    id("idea")
    id("net.minecraftforge.gradle") version "[6.0,6.2)"
    id("org.spongepowered.mixin") version "0.7.38"
}

version = project.property("mod_version") as String
group = project.property("mod_group_id") as String

base {
    archivesName.set(project.property("mod_id") as String)
}

// Mojang ships Java 17 to end users in 1.18+, so your mod should target Java 17.
java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
    }
}

jarJar.enable()

minecraft {
    // The mappings can be changed at any time and must be in the following format.
    // Channel:   Version:
    // official   MCVersion             Official field/method names from Mojang mapping files
    // parchment  YYYY.MM.DD-MCVersion  Open community-sourced parameter names and javadocs layered on top of official
    //
    // You must be aware of the Mojang license when using the 'official' or 'parchment' mappings.
    // See more information here: https://github.com/MinecraftForge/MCPConfig/blob/master/Mojang.md
    //
    // Parchment is an unofficial project maintained by ParchmentMC, separate from MinecraftForge
    // Additional setup is needed to use their mappings: https://github.com/ParchmentMC/Parchment/wiki/Getting-Started
    //
    // Use non-default mappings at your own risk. They may not always work.
    // Simply re-run your setup task after changing the mappings to update your workspace.
    mappings(project.property("mapping_channel") as String, project.property("mapping_version") as String)

    // When true, this property will have all Eclipse/IntelliJ IDEA run configurations run the "prepareX" task for the given run configuration before launching the game.
    // In most cases, it is not necessary to enable.
    // enableEclipsePrepareRuns = true
    // enableIdeaPrepareRuns = true

    // This property allows configuring Gradle's ProcessResources task(s) to run on IDE output locations before launching the game.
    // It is REQUIRED to be set to true for this template to function.
    // See https://docs.gradle.org/current/dsl/org.gradle.language.jvm.tasks.ProcessResources.html
    copyIdeResources = true

    // When true, this property will add the folder name of all declared run configurations to generated IDE run configurations.
    // The folder name can be set on a run configuration using the "folderName" property.
    // By default, the folder name of a run configuration is the name of the Gradle project containing it.
    // generateRunFolders = true

    // This property enables access transformers for use in development.
    // They will be applied to the Minecraft artifact.
    // The access transformer file can be anywhere in the project.
    // However, it must be at "META-INF/accesstransformer.cfg" in the final mod jar to be loaded by Forge.
    // This default location is a best practice to automatically put the file in the right place in the final jar.
    // See https://docs.minecraftforge.net/en/latest/advanced/accesstransformers/ for more information.
    // accessTransformer = file('src/main/resources/META-INF/accesstransformer.cfg')

    // Default run configurations.
    // These can be tweaked, removed, or duplicated as needed.
}

// Include resources generated by data generators.
sourceSets.main.get().resources {
    srcDir("src/generated/resources")
}

repositories {
    // Put repositories for dependencies here
    // ForgeGradle automatically adds the Forge maven and Maven Central for you

    // If you have mod jar dependencies in ./libs, you can declare them as a repository like so:
    // flatDir {
    //     dir 'libs'
    // }
    maven(url = "https://repo.spongepowered.org/repository/maven-public/")

    maven {
        url = uri("https://maven.pkg.github.com/flowerinsnowdh/GreatScrollableTooltips")
        credentials {
            username = System.getenv("GITHUB_USERNAME")
            password = System.getenv("GITHUB_TOKEN")
        }
    }

    maven(url = "https://www.cursemaven.com")
}

dependencies {
    // Specify the version of Minecraft to use.
    // Any artifact can be supplied so long as it has a "userdev" classifier artifact and is a compatible patcher artifact.
    // The "userdev" classifier will be requested and setup by ForgeGradle.
    // If the group id is "net.minecraft" and the artifact id is one of ["client", "server", "joined"],
    // then special handling is done to allow a setup of a vanilla dependency without the use of an external repository.
    minecraft("net.minecraftforge:forge:${project.property("minecraft_version")}-${project.property("forge_version")}")

    // Real mod deobf dependency examples - these get remapped to your current mappings
    // compileOnly fg.deobf("mezz.jei:jei-${mc_version}:${jei_version}:api") // Adds JEI API as a compile dependency
    // runtimeOnly fg.deobf("mezz.jei:jei-${mc_version}:${jei_version}") // Adds the full JEI mod as a runtime dependency
    // implementation fg.deobf("com.tterrag.registrate:Registrate:MC${mc_version}-${registrate_version}") // Adds registrate as a dependency

    // Example mod dependency using a mod jar from ./libs with a flat dir repository
    // This maps to ./libs/coolmod-${mc_version}-${coolmod_version}.jar
    // The group id is ignored when searching -- in this case, it is "blank"
    // implementation fg.deobf("blank:coolmod-${mc_version}:${coolmod_version}")

    // For more info:
    // http://www.gradle.org/docs/current/userguide/artifact_dependencies_tutorial.html
    // http://www.gradle.org/docs/current/userguide/dependency_management.html

    // LegendaryTooltips 1.4.5
    // https://www.curseforge.com/minecraft/mc-mods/legendary-tooltips/files/4662781
    compileOnly(fg.deobf("curse.maven:legendary-tooltips-532127:4662781"))

    // Obscure Tooltips 2.2
    // https://www.curseforge.com/minecraft/mc-mods/obscure-tooltips/files/4686579
    compileOnly(fg.deobf("curse.maven:obscure-tooltips-715660:4686579"))

    implementation("cn.flowerinsnow.greatscrollabletooltips:common:[${project.property("version_common_module")}]")
    jarJar("cn.flowerinsnow.greatscrollabletooltips:common:[${project.property("version_common_module")}]")

    annotationProcessor("org.spongepowered:mixin:0.8.5:processor")
}

// This block of code expands all declared replace properties in the specified resource targets.
// A missing property will result in an error. Properties are expanded using ${} Groovy notation.
// When "copyIdeResources" is enabled, this will also run before the game launches in IDE environments.
// See https://docs.gradle.org/current/dsl/org.gradle.language.jvm.tasks.ProcessResources.html
tasks.processResources.configure {
    val replaceProperties = mapOf(
        "minecraft_version" to project.property("minecraft_version"),
        "minecraft_version_range" to project.property("minecraft_version_range"),
        "forge_version" to project.property("forge_version"),
        "forge_version_range" to project.property("forge_version_range"),
        "loader_version_range" to project.property("loader_version_range"),
        "mod_id" to project.property("mod_id"),
        "mod_name" to project.property("mod_name"),
        "mod_license" to project.property("mod_license"),
        "mod_version" to project.property("mod_version"),
        "mod_authors" to project.property("mod_authors"),
        "mod_description" to project.property("mod_description")
    )

    replaceProperties.forEach(inputs::property)

    filesMatching(listOf("META-INF/mods.toml", "pack.mcmeta")) {
        expand(replaceProperties)
    }
}

// Example for how to get properties into the manifest for reading at runtime.
tasks.jar.configure {
    manifest {
        attributes(
            Pair("Specification-Title", project.property("mod_id")),
            Pair("Specification-Vendor", project.property("mod_authors")),
            Pair("Specification-Version", "1"),
            Pair("Implementation-Title", project.name),
            Pair("Implementation-Version", project.version),
            Pair("Implementation-Vendor", project.property("mod_authors")),
            Pair("Implementation-Timestamp", SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(Date()))
        )
    }

    from(file("../LICENSE"))
    from(file("../NOTICE"))

    // This is the preferred method to reobfuscate your jar file
    finalizedBy("reobfJar")
}

// However if you are in a multi-project build, dev time needs unobfed jar files, so you can delay the obfuscation until publishing by doing:
// tasks.named('publish').configure {
//     dependsOn 'reobfJar'
// }

tasks.withType<JavaCompile>().configureEach {
    options.encoding = "UTF-8" // Use the UTF-8 charset for Java compilation
}

mixin {
    add(sourceSets.main.get(), "mixins.great-scrollable-tooltips.refmap.json")
    config("great-scrollable-tooltips.mixins.json")
}
